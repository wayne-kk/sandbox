import { NextResponse } from "next/server";
import fs from "fs/promises";
import path from "path";

// å®šä¹‰éœ€è¦é‡ç½®çš„å…·ä½“æ–‡ä»¶æ¨¡æ¿
const RESET_FILES_TEMPLATE = {
    "app/layout.tsx": `import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={"antialiased"}
      >
        {children}
      </body>
    </html>
  );
}`,

    "app/page.tsx": `
export default function HomePage() {
  return (
    <main className="min-h-screen w-full bg-background flex flex-col gap-12">
     
    </main>
  );
}
`
};

async function deleteDirectory(dirPath: string): Promise<void> {
    try {
        await fs.rm(dirPath, { recursive: true, force: true });
    } catch (error) {
        // å¿½ç•¥åˆ é™¤ä¸å­˜åœ¨ç›®å½•çš„é”™è¯¯
        if ((error as any).code !== 'ENOENT') {
            throw error;
        }
    }
}

async function deleteComponentsExceptUI(componentsPath: string): Promise<number> {
    let deletedCount = 0;

    try {
        const items = await fs.readdir(componentsPath, { withFileTypes: true });

        for (const item of items) {
            // è·³è¿‡ ui æ–‡ä»¶å¤¹
            if (item.name === 'ui') {
                continue;
            }

            const itemPath = path.join(componentsPath, item.name);

            if (item.isDirectory()) {
                await deleteDirectory(itemPath);
                deletedCount++;
            } else {
                await fs.unlink(itemPath);
                deletedCount++;
            }
        }
    } catch (error) {
        if ((error as any).code !== 'ENOENT') {
            console.error('åˆ é™¤componentsç›®å½•å†…å®¹å¤±è´¥:', error);
            throw error;
        }
    }

    return deletedCount;
}

async function cleanAppDirectory(appPath: string): Promise<number> {
    let deletedCount = 0;

    // ä¿ç•™çš„æ–‡ä»¶åˆ—è¡¨
    const preservedFiles = ['favicon.ico', 'globals.css', 'layout.tsx', 'page.tsx'];

    try {
        const items = await fs.readdir(appPath, { withFileTypes: true });

        for (const item of items) {
            // è·³è¿‡ä¿ç•™çš„æ–‡ä»¶
            if (preservedFiles.includes(item.name)) {
                continue;
            }

            const itemPath = path.join(appPath, item.name);

            if (item.isDirectory()) {
                await deleteDirectory(itemPath);
                deletedCount++;
            } else {
                await fs.unlink(itemPath);
                deletedCount++;
            }
        }
    } catch (error) {
        if ((error as any).code !== 'ENOENT') {
            console.error('åˆ é™¤appç›®å½•å†…å®¹å¤±è´¥:', error);
            throw error;
        }
    }

    return deletedCount;
}

async function resetSpecificFiles(basePath: string): Promise<void> {
    for (const [filePath, content] of Object.entries(RESET_FILES_TEMPLATE)) {
        const fullPath = path.join(basePath, filePath);
        const dir = path.dirname(fullPath);

        // ç¡®ä¿ç›®å½•å­˜åœ¨
        await fs.mkdir(dir, { recursive: true });

        // å†™å…¥æ–‡ä»¶å†…å®¹
        await fs.writeFile(fullPath, content, 'utf-8');
    }
}

export async function POST(request: Request) {
    try {
        const { confirmReset = false } = await request.json();

        if (!confirmReset) {
            return NextResponse.json({
                success: false,
                error: "éœ€è¦ç¡®è®¤é‡ç½®æ“ä½œ"
            }, { status: 400 });
        }

        const sandboxPath = path.join(process.cwd(), 'sandbox');
        const componentsPath = path.join(sandboxPath, 'components');
        const appPath = path.join(sandboxPath, 'app');

        // è®°å½•é‡ç½®å¼€å§‹
        console.log('ğŸ”„ å¼€å§‹é‡ç½®sandbox...');

        let deletedComponentsCount = 0;
        let deletedAppItemsCount = 0;
        let resetFilesCount = 0;

        // 1. åˆ é™¤ components/ ä¸‹é™¤äº† ui æ–‡ä»¶å¤¹çš„æ‰€æœ‰å†…å®¹
        try {
            deletedComponentsCount = await deleteComponentsExceptUI(componentsPath);
            console.log(`âœ… å·²åˆ é™¤ ${deletedComponentsCount} ä¸ªç»„ä»¶æ–‡ä»¶/æ–‡ä»¶å¤¹`);
        } catch (error) {
            console.warn('è­¦å‘Š: åˆ é™¤componentsæ–‡ä»¶æ—¶å‡ºé”™:', error);
        }

        // 2. åˆ é™¤ app/ ä¸‹é™¤äº†æŒ‡å®šä¿ç•™æ–‡ä»¶çš„æ‰€æœ‰å†…å®¹
        try {
            deletedAppItemsCount = await cleanAppDirectory(appPath);
            console.log(`âœ… å·²åˆ é™¤ app/ ä¸‹ ${deletedAppItemsCount} ä¸ªæ–‡ä»¶/æ–‡ä»¶å¤¹`);
        } catch (error) {
            console.warn('è­¦å‘Š: åˆ é™¤appç›®å½•æ–‡ä»¶æ—¶å‡ºé”™:', error);
        }

        // 3. é‡ç½®æŒ‡å®šçš„æ–‡ä»¶ (layout.tsx å’Œ page.tsx)
        try {
            await resetSpecificFiles(sandboxPath);
            resetFilesCount = Object.keys(RESET_FILES_TEMPLATE).length;
            console.log(`âœ… å·²é‡ç½® ${resetFilesCount} ä¸ªæ–‡ä»¶`);
        } catch (error) {
            console.error('é‡ç½®æ–‡ä»¶å¤±è´¥:', error);
            throw error;
        }

        console.log('âœ… Sandboxé‡ç½®å®Œæˆ');

        return NextResponse.json({
            success: true,
            message: "Sandboxå·²æˆåŠŸé‡ç½®",
            details: {
                resetAt: new Date().toISOString(),
                deletedComponents: deletedComponentsCount,
                deletedAppItems: deletedAppItemsCount,
                resetFiles: resetFilesCount,
                resetFilesList: Object.keys(RESET_FILES_TEMPLATE),
                preservedDirectories: ['node_modules', '.next', 'components/ui'],
                preservedAppFiles: ['favicon.ico', 'globals.css', 'layout.tsx', 'page.tsx'],
                preservedFiles: ['å…¶ä»–é…ç½®æ–‡ä»¶ä¿æŒä¸å˜']
            }
        });

    } catch (error: any) {
        console.error('âŒ é‡ç½®sandboxå¤±è´¥:', error);
        return NextResponse.json({
            success: false,
            error: `é‡ç½®å¤±è´¥: ${error.message}`
        }, { status: 500 });
    }
}

export async function GET() {
    return NextResponse.json({
        success: true,
        message: "Sandboxé‡ç½®APIå¯ç”¨",
        resetScope: {
            description: "é€‰æ‹©æ€§é‡ç½® - åˆ é™¤è‡ªå®šä¹‰ç»„ä»¶ã€æ¸…ç†appç›®å½•ã€é‡ç½®æ ¸å¿ƒæ–‡ä»¶",
            deletedContent: [
                "components/ ç›®å½•ä¸‹é™¤ ui æ–‡ä»¶å¤¹å¤–çš„æ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹",
                "app/ ç›®å½•ä¸‹é™¤ favicon.ico, globals.css, layout.tsx, page.tsx å¤–çš„æ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹"
            ],
            resetFiles: Object.keys(RESET_FILES_TEMPLATE),
            preservedContent: [
                "components/ui/ - shadcn/ui ç»„ä»¶åº“",
                "app/favicon.ico, app/globals.css - ä¿ç•™çš„åº”ç”¨æ–‡ä»¶",
                "node_modules/ - ä¾èµ–åŒ…",
                ".next/ - æ„å»ºç¼“å­˜",
                "å…¶ä»–é…ç½®æ–‡ä»¶ - package.json, tsconfig.json, tailwind.config.js ç­‰",
                "lib/ - å·¥å…·å‡½æ•°",
                "public/ - é™æ€èµ„æº"
            ]
        }
    });
}
